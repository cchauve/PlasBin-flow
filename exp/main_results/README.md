# PlasBin-flow: comparison with other plasmid binning methods

## Overview

This directory contains the results of various plasmid binning methods which have been included in the our analysis in the main paper.

Sample set (sset): For this experiments, we have divided the samples in our test dataset into 2 sets. The bacterial species in the first set of samples is supported by gplas (using mlplasmids) whereas that in the second dataset are not.

Evaluation types (et): Evaluations have been carried out at `basepair` as well as `contig` level. 

Length thresholds (th): Finally, we evaluated the results for various minimum contig length thresholds (`0, 100, 1000`). Contigs below these length threshold have been left out of the respective evaluations.

## Evaluating results

To evaluate the performance of plasmid binning methods, we first need to create a database of the true plasmid sequences. We do so using BLAST+ (v2.6.0). 
```
 makeblastdb -in PLASMIDS_FASTA -dbtype nucl -out PLASMIDS_DB
```
where `PLASMIDS_FASTA` is the FASTA file containing the sequences of true plasmids. The accessions numbers for the plasmids related to all the samples used in our experiments can be found in the `samples.csv` file which can be accessed at https://doi.org/10.5281/zenodo.7807303. `PLASMIDS_DB` is the file containing the generated database.

We then map the contigs from the assembly graph onto the database of true plasmid sequences.
```
blastn -task megablast -query ASSEMBLY_FASTA -db PLASMIDS_DB -out MAPPING_FILE -outfmt 6
```
Here, `ASSEMBLY_FASTA` is the FASTA file containing the short read contig sequences. `MAPPING_FILE` is the file containing the results of the blast mapping in output format 6.

The blast results are then postprocessed to be used for evaluation.
```
python scripts/format_blast_output.py PLASMIDS_FASTA ASSEMBLY_FASTA MAPPING_FILE OUTPUT_FILE
```
Here, `PLASMIDS_FASTA`, `ASSEMBLY_FASTA` and `MAPPING_FILE` are as described above while `OUTPUT_FILE` is a TSV file, in which each line has the following information.
```
Plasmid_ID	Contig_ID	%Mapping	Plasmid_Length	Contig_Length
```

Finally, we evaluate the results using the following script.
```
python scripts/evaluate_bins.py -gt GROUND_TRUTH_FILE -out TOOL_RESULTS -eval_dir EVAL_DIR -tool TOOL_ID -th LENGTH_THRESHOLD
```
Here, `GROUND_TRUTH_FILE` is the TSV file generated above after formatting the blast output. `TOOL_ID` is the short id of each tool used in our experiments (refer to table below). `TOOL_RESULTS` is the file containing the output of the method of interest (with the exception of plasmidSPAdes, described below). `EVAL_DIR` is the path to the directory in which you wish to store the evaluations. Finally, `LENGTH_THRESHOLD` is the minimum length threshold; contigs shorter than this threshold will be excluded from the evaluation.

| Tool			| ID	|
|----			| ---	|
| PlasBin-flow	| pbf	|
| PlasBin		| pb	|
| HyAsP			| hy	|
| MOB-recon		| mob	|
| gplas			| gp	|
| plasmidSPAdes	| psp	|

### Postprocessing plasmidSPAdes results
The contigs and assembly graph used as input for plasmidSPAdes were generated by the method internally using SPAdes. To evaluate plasmidSPAdes, we map the contigs to the true plasmids as described above. We use the contigs in the assembly file before chromosome removal for this mapping. Additionally, we also need to map the contigs from this file to the contigs in the plasmid bins (or components) output by plasmidSPAdes. 

We first create a single FASTA file with all predicted plasmid components from plasmidSPAdes.
```
python format_spades_output.py FINAL_CONTIGS_FASTA COMPONENTS_FASTA
```
Here, `FINAL_CONTIGS_FASTA` is the original plasmidSPAdes output file while `COMPONENTS_FASTA` is the formatted file with the sequences of plasmid components. In addition to mapping the input contigs to the ground truth plasmids, we also map them to the plasmidSPAdes predicted components so that each component can be represented as a set of input contigs from the SPAdes assembly graph.

## Obtaining statistics

The scripts to obtain and visualize the statistics have been included in the `scripts` subdirectory. 

We first save the statistics for various combinations of (sset, et, th) in the `eval` subfolder in a CSV file for each combination:
```
python scripts/eval_to_file.py
```

We then visualize the performance of various binning methods:
```
python scripts/create_fig.py -sset X -et EVAL_TYPE -th Y 
```
where `X` is `1` or `2` based on set of samples, `EVAL_TYPE` refers to the desired type of evaluation mentioned above and `Y` is the desired length threshold. 

The following table lists the parameters to be used to generate the figures from the main paper as well as the figures included in the supplementary material.

| Figure	| X		| EVAL_TYPE	|	Y	|
| ------- 	| --- 	| -------	|	--- |
| 1			| 1		| contig	| 1000	|	
| 2			| 1		| basepair	| 1000	|	
| 3			| 2		| contig	| 0		|	
| 4			| 2		| basepair	| 0		|
| S1		| 1		| contig	| 0		|	
| S2		| 1		| basepair	| 0		|	
| S3		| 1		| contig	| 100	|	
| S4		| 1		| basepair	| 100	|	
| S5		| 2		| contig	| 100	|	
| S6		| 2		| basepair	| 100	|
| S7		| 2		| contig	| 1000	|	
| S8		| 2		| basepair	| 1000	|
